# Python Bot for the Game "Friday Night Funkin"
#### Video Demo:  <https://youtu.be/vJexCbU6teU>
<br />

### Introduction:
The game "Friday Night Funkin" is similar to the well-known "Guitar Hero", meaning that the player listens to music and has to press specific keys according to what is displayed on the screen. These types of game can be a lot of fun and also quite addictive! However, especially on higher difficulty settings, they are incredibly hard to play and require probably hundreds of hours of practice to beat.

But what if we had a computer program that is able to play the game for us? This is exactly what this project is about. I developed a bot written in Python that is called "mbot" and this bot is able to beat the game on the hardest difficulty without any problems (even though it doesn't play perfectly).

I used the following website as a framework to guide me through the process of developing the bot:
<https://code.tutsplus.com/how-to-build-a-python-bot-that-can-play-web-games--active-11117t>

There were a number of challenges I had to overcome despite this guideline: First, the guide is written for Windows and I am using Mac OS X, so the python modules to interact with the system are different and I had to do my own research. Second, the guide is for a different game, "Sushi Go Round", which has a more complicated game concept than "Friday Night Funkin", but is less speedy. This meant that the algorithm of how my bot should work would become simpler do design, but I needed to put much more emphasis on a fast performance and reaction time, which will be elaborated on later in this readme. Last, "Sushi Go Round" is played with a mouse and "Friday Night Funkin" is played by keyboard, again resulting in different modules being needed to interact with the game.

### Developing Process:
More sophisticated bots act between the game and the player, using data directly from the game and giving their outputs to the game directly at the same time. My bot, however, mimicks a player, by using the exact same way to obtain data from the game and also using the same output method, in this case keypresses. The advantage of using this simpler method is that I don't need any special interface to the game nor understanding of how it was programmed. Creating this type of bot will be quicker, although a bot with direct connection to the game would most likely have superior performance and use less computing power.

To develop mbot, I first considered what it would be required to do in order to play the game. First, the bot needed to be able to send keypresses to the game, in this case the game accepts inputs of either the 4 arrow keys or the WASD-keys. Second, the bot needs to be able to know what goes on in the game. This means it needs to somehow see the screen and have some algorithm or method to transform that image into data in order to keep track of the in-game events. Lastly, the bot needs to have a method that allows it to combine the keypresses with the in-game events, that is to press the right key at the right time.

It became quite obvious for me that Python is the way to go for this task, because I already had some experience in this language, and it has a huge variety of modules available for all sorts of functionalities that would eventually allow me to attain the "must-have" functions for my bot that I outlined.

### How Does mbot Work?
To achieve its outputs, in this case key presses, mbot uses the Controller() function of pynput.keyboard module. The only 2 functions I need from this controller are .press and .release. These key presses are registered globally, that means if I run mbot in terminal and then switch to the game window, the key presses will be registered in-game, which is what I need. When to press which key needs to be determined in another function.

The most important part of the bot is the function that allows it to "see" what is going on in the game. To achieve this, I use the mss function of mss module, that can screenshot our monitor. Actually there are a lot of other modules that allow for a similar function, but my research showed that mss is by far the quickest, and this will be important later on. Using mss, mbot screenshots a small area of the screen, because in order to keep track of the game, it doesn't need to see the whole screen. In fact, the game shows the player which key to press in a very specific area that stays the same throughout the game, so I just needed to initially find out the coordinates of this area and from then on focus only on this part of the screen. I stored the according variables as constants in the bot, so that they can be changed without trouble, if needed. X_PAD and Y_PAD define where on the screen the area starts, and WIDTH and HEIGHT define the area's size. Interestingly, these coordinates assume a 1280x800 resolution, which is the setting of my Mac. But: The real screen resolution is double (2560x1600) and that causes the screenshot to have a doubled resolution. This means, even though the screenshot should be WIDTH x HEIGHT, it is in fact double, and this caused some trouble for me initially. Luckily, it is easy to solve: If I want to get a coordinate inside the screenshot area at e.g. x=50 and y=100, then I just need to double the values to x=100 and y=200 to account for the doubled resolution. This will be important later. For now, the taken screenshot is just converted to an Image (a function from PIL module) and returned to be used by the next function.

The main function of the bot basically runs an infinite loop that uses the above screenshot function, extracts 8 distinct pixel color values and uses these to compare against known color values, that indicate that a key must be pressed. Since the game has only 4 possible keys (WASD) that can be pressed, it is not too difficult to monitor. If the player only needed to press keys one time, 4 pixel values (one for each key) would be enough, but in the game it is also sometimes required to hold keys, which is indicated at a slightly different position in a slightly different color, so that is why I added another 4 pixels, resulting in 8. I needed to find out what exact value the colors have, that are used to prompt the player. For this, I just took manual screenshots in-game and used a RGB indicator (in my case Digital Colour Meter in Mac Utilities) and then stored all the values in a dictionary. The bot uses a simple combination of if-conditions: If either of the 2 pixels per key matches the according color, then the bot will send that key press. If not, the key will be released. It was needed to use a tolerance when comparing the colors, because if I only compared to the exact value, I got a lot of missed key presses. The tolerance in the bot is between +-5 and +-15 per RGB-value. Lastly, there are 2 peculiarities I needed to consider: First, the infinite loop has a sleep time of 0.05 seconds, to allow the computer to process all of the required commands and not trip over itself. This also allows me to manually kill the bot with a keyboard interrupt, in case it takes over my system with infinite keypresses. The value 0.05 was chosen after a series of experiments and I felt it is close to optimal, with higher values resulting in a lot of missed keypresses because the bot couldn't react quickly enough any more, and lower values leading to worse in-game performance probably due to cluttering up of commands. Second, there was no need to implement a separate "hold" functionality for the key presses, as multiple presses in rapid succession will have the same effect in-game and are much easier to implement. 

Normally, this would be enough, but the game features a special level (level 6) in which the graphics are changed to a pixelated look and the colors also completely change. I solved this by first creating a copy of the bot, changing the color values and making sure the bot is running ok, even in this special level. Once I secured this, my plan was to implement a function that can somehow detect the graphics style that is shown on-screen and switch between the according color values. By doing some research, didn't find any existing function that could do this in a reliable and understandable way, but I stumbled upon a suggestion that said to look for distinct color changes along a line and then checking the distances between those color changes. If they were always a product of a specific value e.g. 12, then it was extremely likely, that the image along which the line was drawn was "blocky" or in other words pixalated. I implemented this function and tested it with the game's levels and it seemed extremely reliable, so I changed the bot to call it once every 5 seconds approximately to keep track of which level the game was currently in and changing it if necessary. This level status was implemented as a simple global variable and allows the bot to index into a dictionary that stores all necessary color information for both normal levels and the special level.

The bot also features a small greeting message at startup, just to tell the user it is running, because unless the game is actually run, the bot will probably not do anything. It is a nice to have, not necessary for the main function.